# v0.6.0 RPC Architecture Roadmap

## Overview
Transform the bridge from a static UUID-based system to a dynamic RPC-based architecture that mirrors the real Web Bluetooth API, enabling true device-agnostic operation.

## Current State (v0.5.x)
- Client must know all UUIDs upfront: `?service=9800&write=9900&notify=9901`
- Bridge pre-connects to specific characteristics
- Limited to devices with known characteristic patterns

## Target State (v0.6.0)
- Client only specifies service UUID (or uses filters): `?service=9800`
- All GATT operations become RPC calls through WebSocket
- Bridge discovers characteristics on-demand
- Full Web Bluetooth API compatibility

## Implementation Phases

### Phase 1: WebSocket Protocol Enhancement
Extend the WebSocket protocol to support RPC-style messages:

```typescript
interface RPCRequest {
  type: 'rpc';
  id: string;  // Request ID for matching responses
  method: string;  // e.g., 'getCharacteristic', 'readValue'
  args: any[];  // Method arguments
}

interface RPCResponse {
  type: 'rpc_response';
  id: string;  // Matches request ID
  result?: any;  // Success result
  error?: string;  // Error message
}
```

### Phase 2: Mock Bluetooth API Updates
Transform the mock methods into RPC calls:

```typescript
class MockBluetoothRemoteGATTService {
  async getCharacteristic(uuid: string) {
    const response = await this.server.device.rpcCall('getCharacteristic', [this.uuid, uuid]);
    return new MockBluetoothRemoteGATTCharacteristic(this, uuid);
  }
  
  async getCharacteristics(uuid?: string) {
    return await this.server.device.rpcCall('getCharacteristics', [this.uuid, uuid]);
  }
}
```

### Phase 3: Bridge RPC Handler
Implement RPC request handling in the bridge:

```typescript
class BleSession {
  private characteristicCache = new Map<string, any>();
  
  async handleRPC(request: RPCRequest): Promise<RPCResponse> {
    switch (request.method) {
      case 'getCharacteristic':
        return await this.getCharacteristic(...request.args);
      case 'getCharacteristics':
        return await this.getCharacteristics(...request.args);
      case 'readValue':
        return await this.readValue(...request.args);
      case 'writeValue':
        return await this.writeValue(...request.args);
      case 'startNotifications':
        return await this.startNotifications(...request.args);
      // ... other GATT methods
    }
  }
}
```

### Phase 4: Dynamic Discovery
Implement lazy characteristic discovery:

```typescript
async getCharacteristic(serviceUuid: string, characteristicUuid: string) {
  const cacheKey = `${serviceUuid}:${characteristicUuid}`;
  
  // Check cache first
  if (this.characteristicCache.has(cacheKey)) {
    return { success: true, uuid: characteristicUuid };
  }
  
  // Discover on demand
  const service = await this.peripheral.discoverServicesAsync([serviceUuid]);
  const char = await service.discoverCharacteristicsAsync([characteristicUuid]);
  
  // Cache for future use
  this.characteristicCache.set(cacheKey, char);
  
  return { success: true, uuid: characteristicUuid, properties: char.properties };
}
```

## Breaking Changes
- URL parameters `write` and `notify` become optional/deprecated
- New RPC message types in WebSocket protocol
- Mock must be updated to latest version

## Migration Path
1. v0.6.0 supports both old (static) and new (RPC) modes
2. Log deprecation warnings when static mode is used
3. v0.7.0 removes static mode support

## Benefits
1. **True Device Agnostic**: Works with any BLE device without code changes
2. **API Compliance**: Mock behaves exactly like real Web Bluetooth
3. **Dynamic Discovery**: No need to know device structure upfront
4. **Better Testing**: Can test device discovery flows
5. **Future Proof**: Easy to add new GATT methods

## Example Usage
```javascript
// Before (v0.5.x) - Must know all UUIDs
const mock = new WebBleMock('ws://localhost:8080', {
  service: '9800',
  write: '9900',
  notify: '9901'
});

// After (v0.6.0) - Discover dynamically
const device = await navigator.bluetooth.requestDevice({
  filters: [{ services: ['9800'] }]
});
const server = await device.gatt.connect();
const service = await server.getPrimaryService('9800');

// These trigger RPC calls to discover characteristics
const writeChar = await service.getCharacteristic('9900');
const notifyChar = await service.getCharacteristic('9901');
```

## Testing Strategy
1. Add RPC tests alongside existing tests
2. Test both cached and uncached paths
3. Test error cases (characteristic not found, etc.)
4. Performance tests for RPC overhead
5. Backward compatibility tests

## Performance Considerations
- Cache discovered services/characteristics
- Batch multiple RPC calls when possible
- Consider pre-warming cache for known devices
- Monitor RPC round-trip times

## Timeline Estimate
- Phase 1 (Protocol): 1 day
- Phase 2 (Mock updates): 1-2 days  
- Phase 3 (Bridge RPC): 2-3 days
- Phase 4 (Discovery): 1-2 days
- Testing & docs: 2 days

Total: ~1.5-2 weeks of development