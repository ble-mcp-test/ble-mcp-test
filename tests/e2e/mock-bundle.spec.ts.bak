import { test, expect } from '@playwright/test';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import * as dotenv from 'dotenv';

// Load environment variables for BLE configuration
dotenv.config({ path: '.env.local' });

const __dirname = dirname(fileURLToPath(import.meta.url));

// Helper to get BLE configuration from environment
function getBleConfig() {
  return {
    device: process.env.BLE_MCP_DEVICE_IDENTIFIER || 'CS108',
    service: process.env.BLE_MCP_SERVICE_UUID || '9800',
    write: process.env.BLE_MCP_WRITE_UUID || '9900',
    notify: process.env.BLE_MCP_NOTIFY_UUID || '9901'
  };
}

/**
 * Test the Web Bluetooth mock bundle to ensure it loads and exports correctly
 */
test.describe('Mock Bundle Export Tests', () => {
  test('should load bundle and expose WebBleMock global', async ({ page }) => {
    // Navigate to a blank page
    await page.goto('about:blank');
    
    // Load the bundle
    const bundlePath = join(__dirname, '../../dist/web-ble-mock.bundle.js');
    await page.addScriptTag({ path: bundlePath });
    
    // Check if WebBleMock global exists
    const hasWebBleMock = await page.evaluate(() => {
      return typeof window.WebBleMock !== 'undefined';
    });
    
    expect(hasWebBleMock).toBe(true);
    
    // Check if injectWebBluetoothMock function exists
    const hasInjectFunction = await page.evaluate(() => {
      return typeof window.WebBleMock?.injectWebBluetoothMock === 'function';
    });
    
    expect(hasInjectFunction).toBe(true);
    
    // Check if MockBluetooth class exists
    const hasMockClass = await page.evaluate(() => {
      return typeof window.WebBleMock?.MockBluetooth === 'function';
    });
    
    expect(hasMockClass).toBe(true);
  });

  test('should inject mock and replace navigator.bluetooth', async ({ page }) => {
    await page.goto('about:blank');
    
    // Load the bundle
    const bundlePath = join(__dirname, '../../dist/web-ble-mock.bundle.js');
    await page.addScriptTag({ path: bundlePath });
    
    // Check initial state
    const beforeInjection = await page.evaluate(() => {
      return {
        hasBluetooth: 'bluetooth' in navigator,
        bluetoothType: typeof navigator.bluetooth
      };
    });
    
    console.log('Before injection:', beforeInjection);
    
    // Inject the mock
    await page.evaluate(() => {
      window.WebBleMock.injectWebBluetoothMock('ws://localhost:8080');
    });
    
    // Check after injection
    const afterInjection = await page.evaluate(() => {
      return {
        hasBluetooth: 'bluetooth' in navigator,
        bluetoothType: typeof navigator.bluetooth,
        hasRequestDevice: typeof navigator.bluetooth?.requestDevice === 'function',
        hasGetAvailability: typeof navigator.bluetooth?.getAvailability === 'function'
      };
    });
    
    console.log('After injection:', afterInjection);
    
    expect(afterInjection.hasBluetooth).toBe(true);
    expect(afterInjection.bluetoothType).toBe('object');
    expect(afterInjection.hasRequestDevice).toBe(true);
    expect(afterInjection.hasGetAvailability).toBe(true);
  });

  test('should create mock device with requestDevice', async ({ page }) => {
    await page.goto('about:blank');
    
    // Load and inject
    const bundlePath = join(__dirname, '../../dist/web-ble-mock.bundle.js');
    await page.addScriptTag({ path: bundlePath });
    
    await page.evaluate(() => {
      window.WebBleMock.injectWebBluetoothMock('ws://localhost:8080');
    });
    
    // Try to request a device
    const deviceInfo = await page.evaluate(async () => {
      try {
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'TestDevice' }]
        });
        
        return {
          success: true,
          hasDevice: device !== null,
          deviceId: device.id,
          deviceName: device.name,
          hasGatt: 'gatt' in device,
          gattHasConnect: typeof device.gatt?.connect === 'function'
        };
      } catch (error) {
        return {
          success: false,
          error: error.message
        };
      }
    });
    
    console.log('Device request result:', deviceInfo);
    
    expect(deviceInfo.success).toBe(true);
    expect(deviceInfo.hasDevice).toBe(true);
    expect(deviceInfo.deviceName).toBe('TestDevice');
    expect(deviceInfo.hasGatt).toBe(true);
    expect(deviceInfo.gattHasConnect).toBe(true);
  });

  test('should verify simulateNotification works with fake battery voltage', async ({ page }) => {
    await page.goto('about:blank');
    
    // Load and inject
    const bundlePath = join(__dirname, '../../dist/web-ble-mock.bundle.js');
    await page.addScriptTag({ path: bundlePath });
    
    await page.evaluate(() => {
      window.WebBleMock.injectWebBluetoothMock('ws://localhost:8080', {
        service: '180f',
        write: '2a19',
        notify: '2a19'
      });
    });
    
    // Test simulateNotification with fake battery voltage
    const simulationResult = await page.evaluate(async () => {
      try {
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'TestDevice' }]
        });
        
        // Don't actually connect (no server running)
        // Create mock device directly and test simulateNotification
        const MockBluetooth = window.WebBleMock.MockBluetooth;
        const mockInstance = new MockBluetooth('ws://localhost:8080');
        const mockDevice = await mockInstance.requestDevice({ filters: [{ namePrefix: 'Test' }] });
        
        // Create a mock service and characteristic
        const mockService = {
          server: { device: mockDevice, connected: true },
          uuid: '180f'
        };
        
        const MockChar = window.WebBleMock.MockBluetoothRemoteGATTCharacteristic || 
                         eval('(' + mockDevice.gatt.getPrimaryService.toString().match(/class\s+(\w+)/)?.[1] + ')');
        
        // Create characteristic instance  
        const char = new (eval(`(${mockDevice.constructor.toString().match(/class\s+MockBluetoothRemoteGATTCharacteristic[^}]+}/)?.[0] || 'Object'})`))();
        
        // Test that we can create the objects without errors
        return {
          hasDevice: !!device,
          hasMockInstance: !!mockInstance,
          hasMockDevice: !!mockDevice,
          deviceName: device.name,
          mockDeviceName: mockDevice.name
        };
      } catch (error) {
        return {
          error: error.message
        };
      }
    });
    
    console.log('Simulation structure test:', simulationResult);
    
    expect(simulationResult.hasDevice).toBe(true);
    expect(simulationResult.deviceName).toBe('TestDevice');
  });

  test('should verify simulateNotification is available', async ({ page }) => {
    await page.goto('about:blank');
    
    // Load and inject
    const bundlePath = join(__dirname, '../../dist/web-ble-mock.bundle.js');
    await page.addScriptTag({ path: bundlePath });
    
    await page.evaluate(() => {
      window.WebBleMock.injectWebBluetoothMock('ws://localhost:8080', {
        service: '180f',
        write: '2a19',
        notify: '2a19'
      });
    });
    
    // Create device and check for simulateNotification
    const hasSimulateMethod = await page.evaluate(async () => {
      try {
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'TestDevice' }]
        });
        
        // Don't actually connect (no server running)
        // Just check the mock structure
        const MockBluetooth = window.WebBleMock.MockBluetooth;
        const mockInstance = new MockBluetooth('ws://localhost:8080');
        const mockDevice = await mockInstance.requestDevice({ filters: [{ namePrefix: 'Test' }] });
        
        // Check if the structure supports our new features
        return {
          hasTransport: 'transport' in mockDevice,
          hasGatt: 'gatt' in mockDevice,
          hasBleConfig: 'bleConfig' in mockDevice
        };
      } catch (error) {
        return {
          error: error.message
        };
      }
    });
    
    console.log('Mock structure check:', hasSimulateMethod);
    
    expect(hasSimulateMethod.hasTransport).toBe(true);
    expect(hasSimulateMethod.hasGatt).toBe(true);
  });

  test('should reuse connection within same session across multiple operations', async ({ page }) => {
    // This test validates that our session-based architecture properly reuses connections
    // within the same Playwright test context (same session)
    
    // Use the existing bridge server on port 8081
    const port = 8081;
    
    // Check if bridge server is running
    const health = await fetch(`http://localhost:${port}/health`).catch(() => null);
    if (!health || !health.ok) {
      console.log('Bridge server not running on port 8081, skipping test');
      return;
    }
    
    try {
      await page.goto('about:blank');
      
      // Capture console logs for debugging
      page.on('console', msg => {
        console.log(`[Browser] ${msg.text()}`);
      });
      
      // Load and inject mock
      const bundlePath = join(__dirname, '../../dist/web-ble-mock.bundle.js');
      await page.addScriptTag({ path: bundlePath });
      
      // Run multiple connect/disconnect cycles
      const results = await page.evaluate(async ({ wsPort, deviceId, service, write, notify }) => {
        // Configure mock with required BLE parameters
        window.WebBleMock.injectWebBluetoothMock(`ws://localhost:${wsPort}`, {
          service,
          write,
          notify
        });
        
        const results = [];
        const cycles = 5;
        
        for (let i = 0; i < cycles; i++) {
          const cycleStart = Date.now();
          
          try {
            // Request device using configured device identifier
            const device = await navigator.bluetooth.requestDevice({
              filters: [{ namePrefix: deviceId }]
            });
            
            // Connect
            const connectStart = Date.now();
            await device.gatt.connect();
            const connectTime = Date.now() - connectStart;
            
            // Get primary service
            const primaryService = await device.gatt.getPrimaryService(`0x${service}`);
            const writeChar = await primaryService.getCharacteristic(`0x${write}`);
            const notifyChar = await primaryService.getCharacteristic(`0x${notify}`);
            
            // Start notifications
            await notifyChar.startNotifications();
            
            // Send GET_BATTERY_VOLTAGE command (0xA000)
            const batteryCommand = new Uint8Array([
              0xA7, 0xB3, 0x02, 0xD9, 0x82, 0x37, 0x00, 0x00, 0xA0, 0x00
            ]);
            
            // Listen for response
            const responsePromise = new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                reject(new Error('Battery response timeout'));
              }, 5000);
              
              const handler = (event) => {
                const data = Array.from(new Uint8Array(event.target.value.buffer));
                // Check for battery voltage response
                if (data.length >= 12 && 
                    data[5] === 0x9E &&  // Response direction byte
                    data[8] === 0xA0 && 
                    data[9] === 0x00) {
                  clearTimeout(timeout);
                  notifyChar.removeEventListener('characteristicvaluechanged', handler);
                  const voltage = (data[10] << 8) | data[11];
                  resolve(voltage);
                }
              };
              
              notifyChar.addEventListener('characteristicvaluechanged', handler);
            });
            
            // Write command
            await writeChar.writeValue(batteryCommand);
            
            // Wait for response
            const batteryVoltage = await responsePromise;
            
            // Test simulateNotification with an obviously fake battery voltage
            const simulatedVoltage = 9999; // Impossibly high voltage to prove it's simulated
            const simulatedResponse = new Uint8Array([
              0xA7, 0xB3, 0x04, 0xD9, 0x82, 0x9E, 0xF7, 0xDD, 
              0xA0, 0x00, 
              (simulatedVoltage >> 8) & 0xFF, // High byte
              simulatedVoltage & 0xFF,        // Low byte
            ]);
            
            // Listen for simulated notification
            const simulatedResponsePromise = new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                reject(new Error('Simulated battery response timeout'));
              }, 2000);
              
              const handler = (event) => {
                const data = Array.from(new Uint8Array(event.target.value.buffer));
                // Check for battery voltage response
                if (data.length >= 12 && 
                    data[5] === 0x9E &&  // Response direction byte
                    data[8] === 0xA0 && 
                    data[9] === 0x00) {
                  clearTimeout(timeout);
                  notifyChar.removeEventListener('characteristicvaluechanged', handler);
                  const voltage = (data[10] << 8) | data[11];
                  resolve(voltage);
                }
              };
              
              notifyChar.addEventListener('characteristicvaluechanged', handler);
            });
            
            // Simulate the notification
            notifyChar.simulateNotification(simulatedResponse);
            
            // Wait for simulated response
            const simulatedBatteryVoltage = await simulatedResponsePromise;
            
            // Stop notifications
            await notifyChar.stopNotifications();
            
            // Disconnect
            await device.gatt.disconnect();
            
            const cycleTime = Date.now() - cycleStart;
            
            results.push({
              cycle: i + 1,
              success: true,
              connectTime,
              cycleTime,
              batteryVoltage,
              simulatedBatteryVoltage
            });
            
          } catch (error) {
            results.push({
              cycle: i + 1,
              success: false,
              error: error.message,
              cycleTime: Date.now() - cycleStart
            });
          }
          
          // Wait for bridge recovery + mock post-disconnect delay
          // This simulates real test behavior with proper cleanup between tests
          if (i < cycles - 1) { // Don't wait after last cycle
            await new Promise(resolve => setTimeout(resolve, 1500)); // 1.5s to ensure clean state
          }
        }
        
        return results;
      }, {
        wsPort: port,
        deviceId: getBleConfig().device,
        service: getBleConfig().service,
        write: getBleConfig().write,
        notify: getBleConfig().notify
      });
      
      console.log('Connect/disconnect cycle results:', results);
      
      // All cycles should succeed
      const successful = results.filter(r => r.success).length;
      expect(successful).toBe(5);
      
      // Connection times should be reasonable (accounting for retries)
      results.forEach(result => {
        if (result.success) {
          expect(result.connectTime).toBeLessThan(10000); // 10s max with retries
          expect(result.cycleTime).toBeLessThan(12000); // 12s max total
          
          // Validate real battery voltage
          expect(result.batteryVoltage).toBeGreaterThan(3000);
          expect(result.batteryVoltage).toBeLessThan(4500);
          
          // Validate simulated battery voltage matches what we sent (impossible value proves it's fake)
          expect(result.simulatedBatteryVoltage).toBe(9999);
          
          console.log(`Cycle ${result.cycle}: Real battery ${result.batteryVoltage}mV (${(result.batteryVoltage/1000).toFixed(2)}V), Simulated ${result.simulatedBatteryVoltage}mV (${(result.simulatedBatteryVoltage/1000).toFixed(2)}V)`);
        }
      });
      
      // Later cycles might be faster if we reduce recovery time for clean disconnects
      const avgFirstTwo = (results[0].cycleTime + results[1].cycleTime) / 2;
      const avgLastTwo = (results[3].cycleTime + results[4].cycleTime) / 2;
      console.log(`Average first 2 cycles: ${avgFirstTwo}ms, last 2: ${avgLastTwo}ms`);
      
    } finally {
      // We're using the existing bridge server, so don't stop it
    }
  });
});